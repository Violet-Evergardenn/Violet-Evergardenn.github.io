[{"title":"week 3","url":"/2024/01/17/week%203/","content":"plurality(候选人)没啥太大的难度\n#include &lt;cs50.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;// Max number of candidates#define MAX 9// Candidates have name and vote counttypedef struct&#123;    string name;    int votes;&#125;candidate;// Array of candidatescandidate candidates[MAX];// Number of candidatesint candidate_count;// Function prototypesbool vote(string name);void print_winner(void);int main(int argc, string argv[])&#123;    // Check for invalid usage    if (argc &lt; 2)    &#123;        printf(&quot;Usage: plurality [candidate ...]\\n&quot;);        return 1;    &#125;    // Populate array of candidates    candidate_count = argc - 1;    if (candidate_count &gt; MAX)    &#123;        printf(&quot;Maximum number of candidates is %i\\n&quot;, MAX);        return 2;    &#125;    for (int i = 0; i &lt; candidate_count; i++)    &#123;        candidates[i].name = argv[i + 1];        candidates[i].votes = 0;    &#125;    int voter_count = get_int(&quot;Number of voters: &quot;);    // Loop over all voters    for (int i = 0; i &lt; voter_count; i++)    &#123;        string name = get_string(&quot;Vote: &quot;);        // Check for invalid vote        if (!vote(name))        &#123;            printf(&quot;Invalid vote.\\n&quot;);        &#125;    &#125;    // Display winner of election    print_winner();&#125;// Update vote totals given a new votebool vote(string name)&#123;    // TODO    int compare = 0;    for(int i=0;i&lt;candidate_count;++i)&#123;        compare = strcmp(candidates[i].name,name);        //如果字符串 s1 小于 s2，则返回一个小于 0 的值。        //如果字符串 s1 等于 s2，则返回 0。        //如果字符串 s1 大于 s2，则返回一个大于 0 的值。        if(!compare)&#123;            candidates[i].votes+=1;            //printf(&quot;compare result-%i,votes-%i\\n&quot;,strcmp(candidates[i].name,name),candidates[i].votes);            return true;        &#125;    &#125;    return false;&#125;// Print the winner (or winners) of the electionvoid print_winner(void)&#123;    // TODO    int sort_max = 0;    if(candidate_count == 1)&#123;        printf(&quot;%s\\n&quot;,candidates[candidate_count-1].name);    &#125;    else&#123;        sort_max = candidates[0].votes;        for(int i=0;i&lt;candidate_count-1;++i)&#123;            if(candidates[i+1].votes &gt; candidates[i].votes)&#123;                sort_max = candidates[i+1].votes;            &#125;        &#125;        //printf(&quot;%i\\n&quot;,sort_max);        for(int j=0;j&lt;candidate_count;++j)&#123;            if(candidates[j].votes == sort_max)&#123;                printf(&quot;%s\\n&quot;,candidates[j].name);            &#125;        &#125;    &#125;    return;&#125;\n\nTideman(很有难度的候选人问题)通过建立有向图来判断\n【CS50x】 Tideman 题解(上) 【CS50x】 Tideman 题解(下)\n#include &lt;cs50.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;// Max number of candidates#define MAX 9// preferences[i][j] is number of voters who prefer i over jint preferences[MAX][MAX];// locked[i][j] means i is locked in over jbool locked[MAX][MAX];// Each pair has a winner, losertypedef struct&#123;    int winner;    int loser;&#125; pair;// Array of candidatesstring candidates[MAX];pair pairs[MAX * (MAX - 1) / 2];int pair_count;int candidate_count;// Function prototypesbool vote(int rank, string name, int ranks[]);void record_preferences(int ranks[]);void add_pairs(void);void sort_pairs(void);void lock_pairs(void);void print_winner(void);bool has_cycles(int loser, int winner);int main(int argc, string argv[])&#123;    // Check for invalid usage    if (argc &lt; 2)    &#123;        printf(&quot;Usage: tideman [candidate ...]\\n&quot;);        return 1;    &#125;    // Populate array of candidates    candidate_count = argc - 1;    if (candidate_count &gt; MAX)    &#123;        printf(&quot;Maximum number of candidates is %i\\n&quot;, MAX);        return 2;    &#125;    for (int i = 0; i &lt; candidate_count; i++)    &#123;        candidates[i] = argv[i + 1];    &#125;    // Clear graph of locked in pairs    for (int i = 0; i &lt; candidate_count; i++)    &#123;        for (int j = 0; j &lt; candidate_count; j++)        &#123;            locked[i][j] = false;        &#125;    &#125;    pair_count = 0;    int voter_count = get_int(&quot;Number of voters: &quot;);    // Query for votes    for (int i = 0; i &lt; voter_count; i++)    &#123;        // ranks[i] is voter&#x27;s ith preference        int ranks[candidate_count];        // Query for each rank        for (int j = 0; j &lt; candidate_count; j++)        &#123;//处理投票            string name = get_string(&quot;Rank %i: &quot;, j + 1);            if (!vote(j, name, ranks))            &#123;                printf(&quot;Invalid vote.\\n&quot;);                return 3;            &#125;        &#125;        record_preferences(ranks);        printf(&quot;\\n&quot;);    &#125;    add_pairs();    sort_pairs();    lock_pairs();    print_winner();    return 0;&#125;// Update ranks given a new vote//首先使用 vote() 来匹配候选人姓名，更新排名数组：bool vote(int rank, string name, int ranks[])&#123;    // TODO    for (int i = 0; i &lt; candidate_count; i++)    &#123;        if (strcmp(candidates[i], name) == 0)        &#123;            ranks[rank] = i;            return true;        &#125;    &#125;    return false;&#125;// Update preferences given one voter&#x27;s ranks//然后通过排名数组来算出偏好数组：void record_preferences(int ranks[])&#123;    // TODO    for (int i = 0; i &lt; candidate_count; i++)    &#123;//很巧妙，通过j=i+1来比出优胜者和失败者        for (int j = i + 1; j &lt; candidate_count; j++)        &#123;            preferences[ranks[i]][ranks[j]]++;        &#125;    &#125;    return;&#125;// Test for preferences//候选人两两对比：谁赢谁void add_pairs(void)&#123;    // TODO    for (int i = 0; i &lt; candidate_count; i++)    &#123;        pair new;        for (int j = i + 1; j &lt; candidate_count; j++)        &#123;            if (preferences[i][j] &gt; preferences[j][i])            &#123;                new.winner = i;                new.loser = j;                pairs[pair_count++] = new;            &#125;            else if (preferences[i][j] &lt; preferences[j][i])            &#123;                new.winner = j;                new.loser = i;                pairs[pair_count++] = new;            &#125;        &#125;    &#125;    return;&#125;// Sort pairs in decreasing order by strength of victory//然后基于胜利强度进行排序：void sort_pairs(void)&#123;    // TODO    int strength[pair_count];    for (int i = 0; i &lt; pair_count; i++)    &#123;        pair p = pairs[i];        strength[i] = preferences[p.winner][p.loser] - preferences[p.loser][p.winner];    &#125;    // Selection sort    //通过比较差值，将最大的优先级最高    for (int i = 0; i &lt; pair_count; i++)    &#123;        int max = i;        for (int j = i + 1; j &lt; pair_count; j++)        &#123;            if (strength[j] &gt; strength[max])            &#123;                max = j;            &#125;        &#125;        pair tmp = pairs[max];        pairs[max] = pairs[i];        pairs[i] = tmp;    &#125;    return;&#125;//最重要的一步是为有向图添加边，同时不能造成循环，所以我们需要实现定义一个递归函数：bool has_cycles(int loser, int winner)&#123;//是否构成循环    // Cyclic path exists    if (loser == winner)    &#123;        return true;    &#125;    for (int i = 0; i &lt; candidate_count; i++)    &#123;        // Check path: loser -&gt; i        if (locked[loser][i])        &#123;            // Check path: i -&gt; winner            if (has_cycles(i, winner))            &#123;                return true;                // If it returns true, loser -&gt; i -&gt; winner path exists                // Add path: winner -&gt; loser will create a cycle            &#125;        &#125;    &#125;    return false;&#125;// Lock pairs into the candidate graph in order, without creating cycles//相连void lock_pairs(void)&#123;    // TODO    for (int i = 0; i &lt; pair_count; i++)    &#123;        if (!has_cycles(pairs[i].loser, pairs[i].winner))        &#123;            locked[pairs[i].winner][pairs[i].loser] = true;        &#125;    &#125;    return;&#125;// Print the winner of the electionvoid print_winner(void)&#123;    // TODO    for (int i = 0; i &lt; candidate_count; i++)    &#123;        bool isLoser = false;        for (int j = 0; j &lt; candidate_count; j++)        &#123;            // j -&gt; i            if (locked[j][i])            &#123;                isLoser = true;                break;            &#125;        &#125;        if (!isLoser)        &#123;            printf(&quot;%s\\n&quot;, candidates[i]);            break;        &#125;    &#125;    return;&#125;","tags":["cs"]},{"title":"P1163 银行贷款","url":"/2023/12/20/P1163%20%E9%93%B6%E8%A1%8C%E8%B4%B7%E6%AC%BE/","content":"所用知识[[二分查找与二分答案#答案为一定精度的小数|小数精度二分]]\n关键是他利率的这个公式很诡异\n#include&lt;bits/stdc++.h&gt;using namespace std;double n,m,k,l,r;bool pd(double x)&#123;//判断当前答案是否满足 \treturn (pow(1.0/(1.0+x),k)&gt;=1-n/m*x);//pow函数，上文已讲&#125;int main()&#123;\tcin&gt;&gt;n&gt;&gt;m&gt;&gt;k;   \t//二分模板\tl=0;r=10;//月利率可能大于1\twhile(r-l&gt;=0.0001)\t&#123;//注意精度问题 \t\tdouble mid=(l+r)/2;\t\tif(pd(mid))r=mid;\t\telse l=mid;\t&#125;\tcout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;l*100;//输出一位小数哦 \treturn 0;&#125; //直接使用setprecision语句的话，他计算的位数是整数位 + 小数位//用fixed才是小数点后的位数，并且自动四舍五入//公式∑&#123;m*[1/（1+ans)]^i&#125;=n 化简德pow(1.0/(1.0+x),k)=1-n/m*x//这个等于在l或者r都可以，因为是唯一解，不存在多个的情况//double result = round(L * 1000) / 10; // 四舍五入并保留一位小数//cout &lt;&lt; result &lt;&lt; &quot;%&quot;;\n"},{"title":"dictionary","url":"/2024/01/02/dictionary/","content":"dictionary.c 主程序\n// 实现字典的功能#include &lt;ctype.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt;#include &quot;dictionary.h&quot;// 表示哈希表中的一个节点typedef struct node&#123;    char word[LENGTH + 1];    struct node *next;&#125; node;// 选择哈希表中桶的数量const unsigned int N = 26;// 哈希表node *table[N];// 返回单词是否在字典中bool check(const char *word)&#123;    // 获取单词的哈希值    unsigned int index = hash(word);    // 遍历链表，查找单词    for (node *tmp = table[index]; tmp != NULL; tmp = tmp-&gt;next)    &#123;        if (strcasecmp(tmp-&gt;word, word) == 0)        &#123;            return true;        &#125;    &#125;    return false;&#125;// 哈希函数，将单词转换为一个数字unsigned int hash(const char *word)&#123;    // 简单的哈希函数：对于每个字母的哈希值，将字母转为大写后减去 &#x27;A&#x27;    unsigned int hash = 0;    for (int i = 0; word[i] != &#x27;\\0&#x27;; i++)    &#123;        hash = (hash &lt;&lt; 2) ^ toupper(word[i]);    &#125;    return hash % N;&#125;// 加载字典到内存中，如果成功返回 true，否则返回 falsebool load(const char *dictionary)&#123;    // 打开字典文件    FILE *file = fopen(dictionary, &quot;r&quot;);    if (file == NULL)    &#123;        return false;    &#125;    // 读取字典中的每个单词    char word[LENGTH + 1];    while (fscanf(file, &quot;%s&quot;, word) != EOF)    &#123;        // 为新单词创建一个节点        node *new_node = malloc(sizeof(node));        if (new_node == NULL)        &#123;            fclose(file);            return false;        &#125;        // 复制单词到节点中        strcpy(new_node-&gt;word, word);        // 哈希单词以获取哈希表中的位置        unsigned int index = hash(word);        // 插入节点到哈希表中        new_node-&gt;next = table[index];        table[index] = new_node;    &#125;    fclose(file);    return true;&#125;// 返回字典中的单词数量，如果尚未加载则返回0unsigned int size(void)&#123;    unsigned int count = 0;    for (int i = 0; i &lt; N; i++)    &#123;        for (node *tmp = table[i]; tmp != NULL; tmp = tmp-&gt;next)        &#123;            count++;        &#125;    &#125;    return count;&#125;// 从内存中卸载字典，如果成功返回 true，否则返回 falsebool unload(void)&#123;    for (int i = 0; i &lt; N; i++)    &#123;        node *cursor = table[i];        while (cursor != NULL)        &#123;            // 保存 next 指针            node *tmp = cursor-&gt;next;            // 释放当前节点            free(cursor);            // 移动到下一个节点            cursor = tmp;        &#125;    &#125;    return true;&#125;\n\ndictionary.h\n// Declares a dictionary&#x27;s functionality#ifndef DICTIONARY_H#define DICTIONARY_H#include &lt;stdbool.h&gt;// Maximum length for a word// (e.g., pneumonoultramicroscopicsilicovolcanoconiosis)#define LENGTH 45// Prototypesbool check(const char *word);unsigned int hash(const char *word);bool load(const char *dictionary);unsigned int size(void);bool unload(void);#endif // DICTIONARY_H\n\nMakefile\nspeller:\tclang -ggdb3 -gdwarf-4 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-gnu-folding-constant -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -c -o speller.o speller.c\tclang -ggdb3 -gdwarf-4 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-gnu-folding-constant -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -c -o dictionary.o dictionary.c\tclang -ggdb3 -gdwarf-4 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-gnu-folding-constant -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -o speller speller.o dictionary.o -lm\n\nspeller.c\n// Implements a spell-checker#include &lt;ctype.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/time.h&gt;#include &quot;dictionary.h&quot;// Undefine any definitions#undef calculate#undef getrusage// Default dictionary#define DICTIONARY &quot;dictionaries/large&quot;// Prototypedouble calculate(const struct rusage *b, const struct rusage *a);int main(int argc, char *argv[])&#123;    // Check for correct number of args    if (argc != 2 &amp;&amp; argc != 3)    &#123;        printf(&quot;Usage: ./speller [DICTIONARY] text\\n&quot;);        return 1;    &#125;    // Structures for timing data    struct rusage before, after;    // Benchmarks    double time_load = 0.0, time_check = 0.0, time_size = 0.0, time_unload = 0.0;    // Determine dictionary to use    char *dictionary = (argc == 3) ? argv[1] : DICTIONARY;    // Load dictionary    getrusage(RUSAGE_SELF, &amp;before);    bool loaded = load(dictionary);    getrusage(RUSAGE_SELF, &amp;after);    // Exit if dictionary not loaded    if (!loaded)    &#123;        printf(&quot;Could not load %s.\\n&quot;, dictionary);        return 1;    &#125;    // Calculate time to load dictionary    time_load = calculate(&amp;before, &amp;after);    // Try to open text    char *text = (argc == 3) ? argv[2] : argv[1];    FILE *file = fopen(text, &quot;r&quot;);    if (file == NULL)    &#123;        printf(&quot;Could not open %s.\\n&quot;, text);        unload();        return 1;    &#125;    // Prepare to report misspellings    printf(&quot;\\nMISSPELLED WORDS\\n\\n&quot;);    // Prepare to spell-check    int index = 0, misspellings = 0, words = 0;    char word[LENGTH + 1];    // Spell-check each word in text    char c;    while (fread(&amp;c, sizeof(char), 1, file))    &#123;        // Allow only alphabetical characters and apostrophes        if (isalpha(c) || (c == &#x27;\\&#x27;&#x27; &amp;&amp; index &gt; 0))        &#123;            // Append character to word            word[index] = c;            index++;            // Ignore alphabetical strings too long to be words            if (index &gt; LENGTH)            &#123;                // Consume remainder of alphabetical string                while (fread(&amp;c, sizeof(char), 1, file) &amp;&amp; isalpha(c));                // Prepare for new word                index = 0;            &#125;        &#125;        // Ignore words with numbers (like MS Word can)        else if (isdigit(c))        &#123;            // Consume remainder of alphanumeric string            while (fread(&amp;c, sizeof(char), 1, file) &amp;&amp; isalnum(c));            // Prepare for new word            index = 0;        &#125;        // We must have found a whole word        else if (index &gt; 0)        &#123;            // Terminate current word            word[index] = &#x27;\\0&#x27;;            // Update counter            words++;            // Check word&#x27;s spelling            getrusage(RUSAGE_SELF, &amp;before);            bool misspelled = !check(word);            getrusage(RUSAGE_SELF, &amp;after);            // Update benchmark            time_check += calculate(&amp;before, &amp;after);            // Print word if misspelled            if (misspelled)            &#123;                printf(&quot;%s\\n&quot;, word);                misspellings++;            &#125;            // Prepare for next word            index = 0;        &#125;    &#125;    // Check whether there was an error    if (ferror(file))    &#123;        fclose(file);        printf(&quot;Error reading %s.\\n&quot;, text);        unload();        return 1;    &#125;    // Close text    fclose(file);    // Determine dictionary&#x27;s size    getrusage(RUSAGE_SELF, &amp;before);    unsigned int n = size();    getrusage(RUSAGE_SELF, &amp;after);    // Calculate time to determine dictionary&#x27;s size    time_size = calculate(&amp;before, &amp;after);    // Unload dictionary    getrusage(RUSAGE_SELF, &amp;before);    bool unloaded = unload();    getrusage(RUSAGE_SELF, &amp;after);    // Abort if dictionary not unloaded    if (!unloaded)    &#123;        printf(&quot;Could not unload %s.\\n&quot;, dictionary);        return 1;    &#125;    // Calculate time to unload dictionary    time_unload = calculate(&amp;before, &amp;after);    // Report benchmarks    printf(&quot;\\nWORDS MISSPELLED:     %d\\n&quot;, misspellings);    printf(&quot;WORDS IN DICTIONARY:  %d\\n&quot;, n);    printf(&quot;WORDS IN TEXT:        %d\\n&quot;, words);    printf(&quot;TIME IN load:         %.2f\\n&quot;, time_load);    printf(&quot;TIME IN check:        %.2f\\n&quot;, time_check);    printf(&quot;TIME IN size:         %.2f\\n&quot;, time_size);    printf(&quot;TIME IN unload:       %.2f\\n&quot;, time_unload);    printf(&quot;TIME IN TOTAL:        %.2f\\n\\n&quot;,           time_load + time_check + time_size + time_unload);    // Success    return 0;&#125;// Returns number of seconds between b and adouble calculate(const struct rusage *b, const struct rusage *a)&#123;    if (b == NULL || a == NULL)    &#123;        return 0.0;    &#125;    else    &#123;        return ((((a-&gt;ru_utime.tv_sec * 1000000 + a-&gt;ru_utime.tv_usec) -                  (b-&gt;ru_utime.tv_sec * 1000000 + b-&gt;ru_utime.tv_usec)) +                 ((a-&gt;ru_stime.tv_sec * 1000000 + a-&gt;ru_stime.tv_usec) -                  (b-&gt;ru_stime.tv_sec * 1000000 + b-&gt;ru_stime.tv_usec)))                / 1000000.0);    &#125;&#125;\n"},{"title":"week 4","url":"/2024/01/17/week%204/","content":"Volume(将wav文件修改音量大小)// Modifies the volume of an audio file#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// Number of bytes in .wav header//.wav格式的头就是44个uint8_t组成的const int HEADER_SIZE = 44;int main(int argc, char *argv[])&#123;    // Check command-line arguments    if (argc != 4)    &#123;        printf(&quot;Usage: ./volume input.wav output.wav factor\\n&quot;);        return 1;    &#125;    // Open files and determine scaling factor    FILE *input = fopen(argv[1], &quot;r&quot;);    if (input == NULL)    &#123;        printf(&quot;Could not open file.\\n&quot;);        return 1;    &#125;    FILE *output = fopen(argv[2], &quot;w&quot;);    if (output == NULL)    &#123;        printf(&quot;Could not open file.\\n&quot;);        return 1;    &#125;    float factor = atof(argv[3]);    // TODO: Copy header from input file to output file    uint8_t header[HEADER_SIZE];    fread(header, HEADER_SIZE, 1, input);    //默认是uint8_t所以直接写44就是默认为44个uint8_t，也可以写成sizeof(header)    fwrite(header, HEADER_SIZE, 1, output);    // TODO: Read samples from input file and write updated data to output file\t//使用int16_t表示2个字节和有符号    int16_t buffer;    while(fread(&amp;buffer,sizeof(buffer),1,input))    &#123;\t    //修改音量大小        buffer =(int16_t)(buffer*factor);        fwrite(&amp;buffer,sizeof(buffer),1,output);    &#125;    // Close files    fclose(input);    fclose(output);&#125;\n\nFilter more(对bmp的图像进行变灰，翻转，模糊，边缘处理)bmp.h(包含处理bmp图像的数据结构)【笔记】位图（.bmp）和矢量图（Vector)\n// BMP-related data types based on Microsoft&#x27;s own#include &lt;stdint.h&gt;/** * Common Data Types * * The data types in this section are essentially aliases for C/C++ * primitive data types. * * Adapted from http://msdn.microsoft.com/en-us/library/cc230309.aspx. * See http://en.wikipedia.org/wiki/Stdint.h for more on stdint.h. */typedef uint8_t  BYTE;typedef uint32_t DWORD;typedef int32_t  LONG;typedef uint16_t WORD;/** * BITMAPFILEHEADER * * The BITMAPFILEHEADER structure contains information about the type, size, * and layout of a file that contains a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183374(VS.85).aspx. */typedef struct&#123;//位图文件头    WORD   bfType;    DWORD  bfSize;    WORD   bfReserved1;    WORD   bfReserved2;    DWORD  bfOffBits;&#125; __attribute__((__packed__))BITMAPFILEHEADER;/** * BITMAPINFOHEADER * * The BITMAPINFOHEADER structure contains information about the * dimensions and color format of a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183376(VS.85).aspx. */typedef struct&#123;//位图信息头    DWORD  biSize;    LONG   biWidth;    LONG   biHeight;    WORD   biPlanes;    WORD   biBitCount;//每个像素的位数1-黑白图，4-16色，8-256色，24-真彩色    DWORD  biCompression;    DWORD  biSizeImage;    LONG   biXPelsPerMeter;    LONG   biYPelsPerMeter;    DWORD  biClrUsed;    DWORD  biClrImportant;&#125; __attribute__((__packed__))BITMAPINFOHEADER;/** * RGBTRIPLE * * This structure describes a color consisting of relative intensities of * red, green, and blue. * * Adapted from http://msdn.microsoft.com/en-us/library/aa922590.aspx. */typedef struct&#123;    BYTE  rgbtBlue;    BYTE  rgbtGreen;    BYTE  rgbtRed;&#125; __attribute__((__packed__))RGBTRIPLE;\n\nhelp.h(形成头文件，并把bmp.h也带进help.c中)#include &quot;bmp.h&quot;// Convert image to grayscalevoid grayscale(int height, int width, RGBTRIPLE image[height][width]);// Reflect image horizontallyvoid reflect(int height, int width, RGBTRIPLE image[height][width]);// Detect edgesvoid edges(int height, int width, RGBTRIPLE image[height][width]);// Blur imagevoid blur(int height, int width, RGBTRIPLE image[height][width]);\n\nhelp.c(实现变灰，翻转，模糊，边缘功能)#include &quot;helpers.h&quot;#include &lt;math.h&gt;// 将图像转换为灰度图void grayscale(int height, int width, RGBTRIPLE image[height][width])&#123;    for (int i = 0; i &lt; height; i++)    &#123;        for (int j = 0; j &lt; width; j++)        &#123;            RGBTRIPLE pixel = image[i][j];            // 计算平均值            BYTE avg = round((pixel.rgbtRed + pixel.rgbtGreen + pixel.rgbtBlue) / 3.0);            //使用 round 函数对平均值进行四舍五入，            // 设置灰度值            image[i][j].rgbtRed = image[i][j].rgbtGreen = image[i][j].rgbtBlue = avg;        &#125;    &#125;&#125;// 将图像水平反射void reflect(int height, int width, RGBTRIPLE image[height][width])&#123;    for (int i = 0; i &lt; height; i++)    &#123;        for (int j = 0; j &lt; width / 2; j++)        &#123;            // 交换像素            RGBTRIPLE temp = image[i][j];            image[i][j] = image[i][width - 1 - j];            image[i][width - 1 - j] = temp;        &#125;    &#125;&#125;// 对图像进行模糊处理void blur(int height, int width, RGBTRIPLE image[height][width])&#123;    RGBTRIPLE temp[height][width];    for (int i = 0; i &lt; height; i++)    &#123;        for (int j = 0; j &lt; width; j++)        &#123;            int sumRed = 0, sumGreen = 0, sumBlue = 0;            int count = 0;            // 计算像素周围的颜色平均值            for (int di = -1; di &lt;= 1; di++)            &#123;                for (int dj = -1; dj &lt;= 1; dj++)                &#123;                    int newI = i + di;                    int newJ = j + dj;                    // 检查边界                    if (newI &gt;= 0 &amp;&amp; newI &lt; height &amp;&amp; newJ &gt;= 0 &amp;&amp; newJ &lt; width)                    &#123;                        RGBTRIPLE pixel = image[newI][newJ];                        sumRed += pixel.rgbtRed;                        sumGreen += pixel.rgbtGreen;                        sumBlue += pixel.rgbtBlue;                        count++;                    &#125;                &#125;            &#125;            // 设置模糊后的颜色值            temp[i][j].rgbtRed = round(sumRed / (float) count);            temp[i][j].rgbtGreen = round(sumGreen / (float) count);            temp[i][j].rgbtBlue = round(sumBlue / (float) count);        &#125;    &#125;    // 将计算的结果复制回原图像    for (int i = 0; i &lt; height; i++)    &#123;        for (int j = 0; j &lt; width; j++)        &#123;            image[i][j] = temp[i][j];        &#125;    &#125;&#125;// 边缘检测void edges(int height, int width, RGBTRIPLE image[height][width])&#123;    // 创建一个临时图像来存储新的像素值    RGBTRIPLE temp[height][width];    // Sobel算子    int Gx[3][3] = &#123;&#123;-1, 0, 1&#125;, &#123;-2, 0, 2&#125;, &#123;-1, 0, 1&#125;&#125;;    int Gy[3][3] = &#123;&#123;-1, -2, -1&#125;, &#123;0, 0, 0&#125;, &#123;1, 2, 1&#125;&#125;;    for (int i = 0; i &lt; height; i++)    &#123;        for (int j = 0; j &lt; width; j++)        &#123;            float sumRedX = 0, sumGreenX = 0, sumBlueX = 0;            float sumRedY = 0, sumGreenY = 0, sumBlueY = 0;            // 应用Sobel算子            for (int di = -1; di &lt;= 1; di++)            &#123;                for (int dj = -1; dj &lt;= 1; dj++)                &#123;                    if (i + di &lt; 0 || i + di &gt;= height || j + dj &lt; 0 || j + dj &gt;= width)                    &#123;                        continue;                    &#125;                    RGBTRIPLE pixel = image[i + di][j + dj];                    sumRedX += pixel.rgbtRed * Gx[di + 1][dj + 1];                    sumGreenX += pixel.rgbtGreen * Gx[di + 1][dj + 1];                    sumBlueX += pixel.rgbtBlue * Gx[di + 1][dj + 1];                    sumRedY += pixel.rgbtRed * Gy[di + 1][dj + 1];                    sumGreenY += pixel.rgbtGreen * Gy[di + 1][dj + 1];                    sumBlueY += pixel.rgbtBlue * Gy[di + 1][dj + 1];                &#125;            &#125;            // 计算新的RGB值            int red = round(sqrt(sumRedX * sumRedX + sumRedY * sumRedY));            int green = round(sqrt(sumGreenX * sumGreenX + sumGreenY * sumGreenY));            int blue = round(sqrt(sumBlueX * sumBlueX + sumBlueY * sumBlueY));            // 确保像素值在0-255的范围内            temp[i][j].rgbtRed = (red &gt; 255) ? 255 : red;            temp[i][j].rgbtGreen = (green &gt; 255) ? 255 : green;            temp[i][j].rgbtBlue = (blue &gt; 255) ? 255 : blue;        &#125;    &#125;    // 将计算出的新像素值复制回原图像    for (int i = 0; i &lt; height; i++)    &#123;        for (int j = 0; j &lt; width; j++)        &#123;            image[i][j] = temp[i][j];        &#125;    &#125;&#125;\n\nfilter.c(集合所有，实现目标)#include &lt;getopt.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;helpers.h&quot;int main(int argc, char *argv[])&#123;    // Define allowable filters    char *filters = &quot;begr&quot;;    // Get filter flag and check validity    //要使用getopt要在执行程序时使用 &#x27;-&#x27;,否则getopt无法识别到    char filter = getopt(argc, argv, filters);//getopt函数也是用地址的    //代码首先定义了一个字符串filters，包含了允许的过滤器字符。然后，使用getopt函数来获取命令行参数中的过滤器选项。如果获取getopt返回的是-1，filter就会被赋值为&#x27;?&#x27;，表示没找到许的过滤器字符    if (filter == &#x27;?&#x27;)    &#123;        printf(&quot;Invalid filter.\\n&quot;);        return 1;    &#125;    // Ensure only one filter    //接下来，代码再次调用getopt函数，以确保只允许使用一个过滤器。如果再次调用getopt函数后返回的值不是-1，说明已经使用了多个过滤器，    //getopt函数是会自己移动的，它会从剩余的命令行参数中继续查找，直到找到下一个有效的过滤器选项或者没有更多的参数为止。    if (getopt(argc, argv, filters) != -1)    &#123;        printf(&quot;Only one filter allowed.\\n&quot;);        return 2;    &#125;    // Ensure proper usage    if (argc != optind + 2)    &#123;//这个判断是在检查命令行参数的数量是否正确。如果不正确，程序会打印使用方法并返回错误代码3。        printf(&quot;Usage: ./filter [flag] infile outfile\\n&quot;);        return 3;    &#125;    // Remember filenames    char *infile = argv[optind];    //optind 是一个全局变量，它在 &lt;unistd.h&gt; 头文件中定义。这个变量用于记录命令行参数的解析进度，通常与 getopt 函数一起使用。//    //因为数组是从0开始计算的，但是argc和optind都是从1开始计算的    //所以是argv[optind]    char *outfile = argv[optind + 1];    // Open input file    FILE *inptr = fopen(infile, &quot;r&quot;);    if (inptr == NULL)    &#123;        printf(&quot;Could not open %s.\\n&quot;, infile);        return 4;    &#125;    // Open output file    FILE *outptr = fopen(outfile, &quot;w&quot;);    if (outptr == NULL)    &#123;        fclose(inptr);        printf(&quot;Could not create %s.\\n&quot;, outfile);        return 5;    &#125;    // Read infile&#x27;s BITMAPFILEHEADER    BITMAPFILEHEADER bf;    fread(&amp;bf, sizeof(BITMAPFILEHEADER), 1, inptr);    // Read infile&#x27;s BITMAPINFOHEADER    BITMAPINFOHEADER bi;    fread(&amp;bi, sizeof(BITMAPINFOHEADER), 1, inptr);    // Ensure infile is (likely) a 24-bit uncompressed BMP 4.0    if (bf.bfType != 0x4d42 || bf.bfOffBits != 54 || bi.biSize != 40 ||        bi.biBitCount != 24 || bi.biCompression != 0)    &#123;        fclose(outptr);        fclose(inptr);        printf(&quot;Unsupported file format.\\n&quot;);        return 6;    &#125;    // Get image&#x27;s dimensions    int height = abs(bi.biHeight);    int width = bi.biWidth;    // Allocate memory for image    RGBTRIPLE(*image)[width] = calloc(height, width * sizeof(RGBTRIPLE));    //(*image)[width] 这段代码的意思是声明一个指向 RGBTRIPLE 类型的指针数组，其中每个指针指向一个包含 width     //个 RGBTRIPLE 元素的数组。这样就可以创建一个包含 height 行、width 列的二维数组结构。    //这行代码做了以下几件事情：    //使用 calloc 函数动态分配了一个二维数组，数组的行数是 height，列数是 width。    //为了声明这个二维数组，使用了指向 RGBTRIPLE 结构体的指针，这个指针指向一个长度为 width 的一维数组。    //将分配的内存赋值给 image，这样 image 就指向了一个二维数组，可以用来存储图像的像素信息。    if (image == NULL)    &#123;        printf(&quot;Not enough memory to store image.\\n&quot;);        fclose(outptr);        fclose(inptr);        return 7;    &#125;    //这段代码是用来从输入文件中读取图像的像素数据，并跳过每行的填充字节。    //在BMP格式的图像文件中，每行像素数据存储后会进行填充，使得每行的字节数是4的倍数。    //start    // Determine padding for scanlines    int padding = (4 - (width * sizeof(RGBTRIPLE)) % 4) % 4;    // Iterate over infile&#x27;s scanlines    for (int i = 0; i &lt; height; i++)    &#123;        // Read row into pixel array        fread(image[i], sizeof(RGBTRIPLE), width, inptr);        // Skip over padding        fseek(inptr, padding, SEEK_CUR);    &#125;    //over    // Filter image    switch (filter)    &#123;        // Blur        case &#x27;b&#x27;:            blur(height, width, image);            break;        // Edges        case &#x27;e&#x27;:            edges(height, width, image);            break;        // Grayscale        case &#x27;g&#x27;:            grayscale(height, width, image);            break;        // Reflect        case &#x27;r&#x27;:            reflect(height, width, image);            break;    &#125;    // Write outfile&#x27;s BITMAPFILEHEADER    fwrite(&amp;bf, sizeof(BITMAPFILEHEADER), 1, outptr);    // Write outfile&#x27;s BITMAPINFOHEADER    fwrite(&amp;bi, sizeof(BITMAPINFOHEADER), 1, outptr);    // Write new pixels to outfile    for (int i = 0; i &lt; height; i++)    &#123;        // Write row to outfile        fwrite(image[i], sizeof(RGBTRIPLE), width, outptr);        // Write padding at end of row        for (int k = 0; k &lt; padding; k++)        &#123;            fputc(0x00, outptr);        &#125;    &#125;    // Free memory for image    free(image);    // Close files    fclose(inptr);    fclose(outptr);    return 0;&#125;\n\n./filter g images/yard.bmp out.bmp //这样就是错的 ./filter -g images/yard.bmp out.bmp // 这样才是对的\n\nMakefile(作用是使用make的时候把help.c和filter.c整合到一起)filter:    clang -ggdb3 -gdwarf-4 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-gnu-folding-constant -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -lm -o filter filter.c helpers.c\n\nrecover(从存储卡中恢复JPEG文件)这种是在我们默认数码相机将照片连续存储在存储卡上才可以这样写的\n#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef uint8_t BYTE;int main(int argc, char *argv[])&#123;    // 确保正确的命令行参数    if (argc != 2)    &#123;        printf(&quot;Usage: ./recover image\\n&quot;);        return 1;    &#125;    // 打开取证镜像文件    FILE *file = fopen(argv[1], &quot;r&quot;);    if (file == NULL)    &#123;        printf(&quot;Could not open file.\\n&quot;);        return 1;    &#125;    BYTE buffer[512];    FILE *img = NULL;    int filecount = 0;    char filename[8];    // 读取文件直到结束    while (fread(buffer, 1, 512, file) == 512)    &#123;        // 检查是否为JPEG文件的开始        if (buffer[0] == 0xff &amp;&amp; buffer[1] == 0xd8 &amp;&amp; buffer[2] == 0xff &amp;&amp; (buffer[3] &amp; 0xf0) == 0xe0)//位运算符是在二进制下处理的        &#123;            // 如果已经打开了一个JPEG文件，则关闭它            if (img != NULL)            &#123;                fclose(img);            &#125;            // 为新JPEG文件命名并打开它            sprintf(filename, &quot;%03i.jpg&quot;, filecount++);            img = fopen(filename, &quot;w&quot;);            if (img == NULL)            &#123;                printf(&quot;Could not create image.\\n&quot;);                fclose(file);                return 1;            &#125;        &#125;        // 如果已找到JPEG文件的开始，写入文件        if (img != NULL)        &#123;            fwrite(buffer, 1, 512, img);        &#125;    &#125;    // 关闭最后一个JPEG文件和取证镜像文件    if (img != NULL)    &#123;        fclose(img);    &#125;    fclose(file);    return 0;&#125;","tags":["cs"]},{"title":"非算法类","url":"/2023/12/20/%E9%9D%9E%E7%AE%97%E6%B3%95%E7%B1%BB/","content":"从文件读入，输出到文件里通过头文件\n#include &lt;fstream&gt;ifstream inputFile(&quot;文件名称&quot;);//输入ofstream outputFile(&quot;文件名称&quot;);//输出\n\n\n改写为二进制存入文件，并读取输出\nwrite((char*)&amp;s,sizeof(s));这行代码的意思是将变量s的内存地址转换为char指针，并将其内容写入输出流中，写入的字节数为s的大小。这通常用于将变量s的二进制表示写入文件或网络流中。\n输出为二进制文本\n读取二进制文本\n"},{"title":"week 5","url":"/2024/01/17/week%205/","content":"Inheritance(随机生成3代血型遗传)#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;// 每个人有两个父母和两个等位基因typedef struct person&#123;    struct person *parents[2];    char alleles[2];&#125; person;const int GENERATIONS = 3;const int INDENT_LENGTH = 4;person *create_family(int generations);void print_family(person *p, int generation);void free_family(person *p);char random_allele();int main(void)&#123;    // 初始化随机数生成器    srand(time(0));    // 创建一个有三代的新家庭    person *p = create_family(GENERATIONS);    // 打印血型的家族树    print_family(p, 0);    // 释放内存    free_family(p);&#125;// 根据 `generations` 创建一个新个体person *create_family(int generations)&#123;    // 为新个体分配内存    person *new_person = malloc(sizeof(person));    if (new_person == NULL)    &#123;        fprintf(stderr, &quot;内存分配失败\\n&quot;);        exit(1);    &#125;    // 如果还有更多代需要创建    if (generations &gt; 1)    &#123;        // 递归调用 create_family 创建当前个体的两个新父母        new_person-&gt;parents[0] = create_family(generations - 1);        new_person-&gt;parents[1] = create_family(generations - 1);        // 基于父母的等位基因随机分配当前个体的等位基因        new_person-&gt;alleles[0] = new_person-&gt;parents[0]-&gt;alleles[rand() % 2];        new_person-&gt;alleles[1] = new_person-&gt;parents[1]-&gt;alleles[rand() % 2];    &#125;    else // 基案：没有更多代需要创建    &#123;        // 将父母指针设置为 NULL        new_person-&gt;parents[0] = NULL;        new_person-&gt;parents[1] = NULL;        // 随机分配等位基因        new_person-&gt;alleles[0] = random_allele();        new_person-&gt;alleles[1] = random_allele();    &#125;    // 返回新创建的个体    return new_person;&#125;// 释放 `p` 及其所有祖先的内存void free_family(person *p)&#123;    // 处理基案    if (p == NULL)    &#123;        return;    &#125;    // 递归释放父母的内存    free_family(p-&gt;parents[0]);    free_family(p-&gt;parents[1]);    // 释放当前个体的内存    free(p);&#125;// 打印每个家庭成员及其等位基因void print_family(person *p, int generation)&#123;    // 处理基案    if (p == NULL)    &#123;        return;    &#125;    // 打印缩进    for (int i = 0; i &lt; generation * INDENT_LENGTH; i++)    &#123;        printf(&quot; &quot;);    &#125;    // 打印个体    if (generation == 0)    &#123;        printf(&quot;Child (Generation %i): blood type %c%c\\n&quot;, generation, p-&gt;alleles[0], p-&gt;alleles[1]);    &#125;    else if (generation == 1)    &#123;        printf(&quot;Parent (Generation %i): blood type %c%c\\n&quot;, generation, p-&gt;alleles[0], p-&gt;alleles[1]);    &#125;    else    &#123;        for (int i = 0; i &lt; generation - 2; i++)        &#123;            printf(&quot;Great-&quot;);        &#125;        printf(&quot;Grandparent (Generation %i): blood type %c%c\\n&quot;, generation, p-&gt;alleles[0], p-&gt;alleles[1]);    &#125;    // 打印当前代的父母    print_family(p-&gt;parents[0], generation + 1);    print_family(p-&gt;parents[1], generation + 1);&#125;// 随机选择一个血型等位基因char random_allele()&#123;    int r = rand() % 3;    if (r == 0)    &#123;        return &#x27;A&#x27;;    &#125;    else if (r == 1)    &#123;        return &#x27;B&#x27;;    &#125;    else    &#123;        return &#x27;O&#x27;;    &#125;&#125;\n\nSpeller(处理在字典中的单词考hash，load字典进入内存，check，size内存中的单词数，unload内存)dictionary.h// Declares a dictionary&#x27;s functionality#ifndef DICTIONARY_H#define DICTIONARY_H#include &lt;stdbool.h&gt;// Maximum length for a word// (e.g., pneumonoultramicroscopicsilicovolcanoconiosis)#define LENGTH 45// Prototypesbool check(const char *word);unsigned int hash(const char *word);bool load(const char *dictionary);unsigned int size(void);bool unload(void);#endif // DICTIONARY_H\n\ndictionary.c// 实现字典的功能#include &lt;ctype.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt;#include &quot;dictionary.h&quot;// 表示哈希表中的一个节点typedef struct node&#123;    char word[LENGTH + 1];    struct node *next;&#125; node;// 选择哈希表中桶的数量const unsigned int N = 26;// 哈希表node *table[N];// 返回单词是否在字典中bool check(const char *word)&#123;    // 获取单词的哈希值    unsigned int index = hash(word);    // 遍历链表，查找单词    for (node *tmp = table[index]; tmp != NULL; tmp = tmp-&gt;next)    &#123;        if (strcasecmp(tmp-&gt;word, word) == 0)        &#123;            return true;        &#125;    &#125;    return false;&#125;// 哈希函数，将单词转换为一个数字unsigned int hash(const char *word)&#123;    // 简单的哈希函数：对于每个字母的哈希值，将字母转为大写后减去 &#x27;A&#x27;    unsigned int hash = 0;    for (int i = 0; word[i] != &#x27;\\0&#x27;; i++)    &#123;        hash = (hash &lt;&lt; 2) ^ toupper(word[i]);    &#125;    return hash % N;&#125;// 加载字典到内存中，如果成功返回 true，否则返回 falsebool load(const char *dictionary)&#123;    // 打开字典文件    FILE *file = fopen(dictionary, &quot;r&quot;);    if (file == NULL)    &#123;        return false;    &#125;    // 读取字典中的每个单词    char word[LENGTH + 1];    while (fscanf(file, &quot;%s&quot;, word) != EOF)    &#123;        // 为新单词创建一个节点        node *new_node = malloc(sizeof(node));        if (new_node == NULL)        &#123;            fclose(file);            return false;        &#125;        // 复制单词到节点中        strcpy(new_node-&gt;word, word);        // 哈希单词以获取哈希表中的位置        unsigned int index = hash(word);        // 插入节点到哈希表中        new_node-&gt;next = table[index];        table[index] = new_node;    &#125;    fclose(file);    return true;&#125;// 返回字典中的单词数量，如果尚未加载则返回0unsigned int size(void)&#123;    unsigned int count = 0;    for (int i = 0; i &lt; N; i++)    &#123;        for (node *tmp = table[i]; tmp != NULL; tmp = tmp-&gt;next)        &#123;            count++;        &#125;    &#125;    return count;&#125;// 从内存中卸载字典，如果成功返回 true，否则返回 falsebool unload(void)&#123;    for (int i = 0; i &lt; N; i++)    &#123;        node *cursor = table[i];        while (cursor != NULL)        &#123;            // 保存 next 指针            node *tmp = cursor-&gt;next;            // 释放当前节点            free(cursor);            // 移动到下一个节点            cursor = tmp;        &#125;    &#125;    return true;&#125;\n\nMakefilespeller:\tclang -ggdb3 -gdwarf-4 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-gnu-folding-constant -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -c -o speller.o speller.c\tclang -ggdb3 -gdwarf-4 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-gnu-folding-constant -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -c -o dictionary.o dictionary.c\tclang -ggdb3 -gdwarf-4 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-gnu-folding-constant -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -o speller speller.o dictionary.o -lm最后，回想一下，它可以 make 自动编译代码，这样您就不必手动执行 clang 一大堆开关。但是，随着程序大小的增长， make 将无法再从上下文中推断如何编译代码;你需要开始告诉你 make 如何编译你的程序，特别是当它们涉及多个源文件（即， .c ）时，就像这个问题一样。因此 Makefile ，我们将使用 ，一个配置文件，它准确地告诉 make 要做什么。打开 Makefile ，您应该看到四行：第一行告诉 make 在你自己执行（或只是 make ）时执行 make speller 后续行。第二行告诉 make 如何编译 speller.c 成机器代码（即 speller.o ）。第三行讲述了 make 如何编译 dictionary.c 成机器代码（即 dictionary.o ）。第四行告诉 make 链接 speller.o 和 dictionary.o 一个名为 speller .请务必 speller 通过执行 make speller （或仅 make ）进行编译。执行 make dictionary 是行不通的！","tags":["cs"]},{"title":"ok","url":"/2024/01/30/ok/","content":"很好\n"}]